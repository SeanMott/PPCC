/*
Finds all object generated by DTK that have a .skip inside of them.
Renames them and their symbol to SKIP_RESERVE_XXX
*/

#include <PowerPCParser/Lexing/Lexer.hpp>
#include <PowerPCParser/GeneralAST/GeneralAST.hpp>
#include <PowerPCParser/FineGrainAST/FineGrainAST.hpp>
#include <PowerPCParser/CppCodeGen/CppCodeGen.hpp>

#include <BTDSTD/IO/File.hpp>

#include <filesystem>


//performs the entire DTK ASM to C++ pipeline
static inline void ConvertASMToCpp(const std::string& filepath, const std::string& filename, const std::string& dumpFileDir)
{
	//reads file
	BTD::IO::File file;
	file.Open(filepath.c_str(), BTD::IO::FileOP::TextRead_OpenExisting);
	std::string ASMText = ""; file.ReadAllText(ASMText);
	file.Close();

	//Step 1: Lex the entire file and tag all the tokens
	std::vector<PPC::Token::Token> tokens = PPC::Parser::LexASMIntoTokesn(ASMText);
	ASMText.clear();
	//PPC::Parser::PrintAndDump_ASMTokens(tokens, dumpFileDir, filename);

	//Step 2: General AST and define where structs and functions generally are
	std::vector<PPC::AST::FirstPass::ASTFirstPass_Node> firstPassASTTree = PPC::AST::FirstPass::GenerateFirstPassASTTree(tokens);
	tokens.clear();
	//PrintAndDump_FirstPassASMAST(firstPassASTTree, dumpFileDir, filename);

	//Step 3: Second pass to take the existing AST and add more details of types and specific variables
	std::vector<PPC::AST::SecondPass::ASTSecondPass_Node> secondPassASTTree = PPC::AST::SecondPass::GenerateSecondPassASTTree(firstPassASTTree);
	firstPassASTTree.clear();
	//PrintAndDump_SecondPassASMAST(secondPassASTTree, dumpFileDir, filename);

	//Step 4: First Pass of the C++ code gen
	std::vector<PPC::Backend::CppCodeGen::CodeGenNode> firstPassCppCodeGen = PPC::Backend::CppCodeGen::RunCodeGen(secondPassASTTree);
	secondPassASTTree.clear();
	PPC::Backend::CppCodeGen::PrintAndDump_CppCodeGen(firstPassCppCodeGen, dumpFileDir, filename);
}

//entry point
int main(int args, char* argv[])
{
	//--init

	//gets symbol file
	//std::string filepath = "C:\\KARTools\\KAR-Decomp\\asm\\symbols.txt";
	//
	////reads file
	BTD::IO::File file; //file.Open(filepath.c_str(), BTD::IO::FileOP::TextRead_OpenExisting);
	//std::string symbolText = ""; file.ReadAllText(symbolText);
	//file.Close();

	//lexes
	//PPC::Parser::LexSymbolFile(symbolText);

	std::string ASMDir = "C:\\KARTools\\KAR-Decomp\\asm";
	std::string COutputDir = "C:\\KARTools\\KAR-Decomp\\PPC_COutput";

	//goes through each file and generate the C++
	std::string path = ASMDir;
	for (const auto& entry : std::filesystem::directory_iterator(path))
	{
		if (!entry.is_regular_file())
			continue;
	
		std::string filepath = entry.path().string();
	
		std::string filename = entry.path().filename().string();
		filename.resize(filename.size() - 2); //strip extension
	
		//runs all stages of the ASM to C++ pipeline
		ConvertASMToCpp(filepath, filename, COutputDir);
	}

	//manually set the file path
	//std::string filename = "auto_12_805E62E0_sbss2";
	//std::string filename = "auto_11_805DE700_sdata2";
	//std::string filename = "__init_cpp_exceptions";
	//std::string filename = "auto___destroy_global_chain_text";
	//std::string filename = "auto_00_80003100_init";
	//std::string filename = "auto_03_803AF810_text";
	//std::string filename = "auto_03_803AF810_text";
	//std::string filepath = ASMDir + "\\" + filename + ".s";
	
	//runs all stages of the ASM to C++ pipeline
	//std::string filepath = ASMDir + "//" + filename + ".s";
	//ConvertASMToCpp(filepath, filename, COutputDir);

	getchar(); //holds console
	return 0;
}