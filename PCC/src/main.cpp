/*
Finds all object generated by DTK that have a .skip inside of them.
Renames them and their symbol to SKIP_RESERVE_XXX
*/

#include <PowerPCParser/Lexing/Lexer.hpp>
#include <PowerPCParser/GeneralAST/GeneralAST.hpp>
#include <PowerPCParser/FineGrainAST/FineGrainAST.hpp>
#include <PowerPCParser/CppCodeGen/CppCodeGen.hpp>

#include <BTDSTD/IO/File.hpp>

#include <filesystem>


//performs the entire DTK ASM to C++ pipeline
static inline void ConvertASMToCpp(const std::string& filepath, const std::string& filename, const std::string& dumpFileDir)
{
	//reads file
	BTD::IO::File file;
	file.Open(filepath.c_str(), BTD::IO::FileOP::TextRead_OpenExisting);
	std::string ASMText = ""; file.ReadAllText(ASMText);
	file.Close();

	//Step 1: Lex the entire file and tag all the tokens
	std::vector<PPC::Token::Token> tokens = PPC::Parser::LexASMIntoTokesn(ASMText);
	ASMText.clear();
	//PPC::Parser::PrintAndDump_ASMTokens(tokens, dumpFileDir, filename);

	//Step 2: General AST and define where structs and functions generally are
	std::vector<PPC::AST::FirstPass::ASTFirstPass_Node> firstPassASTTree = PPC::AST::FirstPass::GenerateFirstPassASTTree(tokens);
	tokens.clear();
	//PrintAndDump_FirstPassASMAST(firstPassASTTree, dumpFileDir, filename);

	//Step 3: Second pass to take the existing AST and add more details of types and specific variables
	std::vector<PPC::AST::SecondPass::ASTSecondPass_Node> secondPassASTTree = PPC::AST::SecondPass::GenerateSecondPassASTTree(firstPassASTTree);
	firstPassASTTree.clear();
	//PrintAndDump_SecondPassASMAST(secondPassASTTree, dumpFileDir, filename);

	//Step 4: First Pass of the C++ code gen
	std::vector<PPC::Backend::CppCodeGen::CodeGenNode> firstPassCppCodeGen = PPC::Backend::CppCodeGen::RunCodeGen(secondPassASTTree, filename);
	secondPassASTTree.clear();
	PPC::Backend::CppCodeGen::PrintAndDump_CppCodeGen(firstPassCppCodeGen, dumpFileDir, filename);
}

//entry point
int main(int args, char* argv[])
{
	//--init

	std::string ASMDir = "C:\\Decomps\\TowerOfDruaga\\asm";
	std::string COutputDir = "C:\\Decomps\\TowerOfDruaga\\PPC_COutput";

	//if there are flags
	if (args > 1)
	{
		for (uint32 i = 1; i < args; ++i)
		{
			//checks for the -asm flag
			if (!strcmp(argv[i], "-asm") && i + 1 < args)
			{
				ASMDir = argv[i + 1];
			}

			//checks for the -symbolFile flag
			if (!strcmp(argv[i], "-cout") && i + 1 < args)
			{
				COutputDir = argv[i + 1];
			}
		}
	}

	//goes through each file and generate the C++
	std::string path = ASMDir;
	for (const auto& entry : std::filesystem::directory_iterator(path))
	{
		if (!entry.is_regular_file())
			continue;
	
		std::string filepath = entry.path().string();
	
		std::string filename = entry.path().filename().string();
		filename.resize(filename.size() - 2); //strip extension
	
		//runs all stages of the ASM to C++ pipeline
		ConvertASMToCpp(filepath, filename, COutputDir);
	}

	getchar(); //holds console
	return 0;
}